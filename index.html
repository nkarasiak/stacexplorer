<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- GitHub Pages SPA Redirect Handler -->
    <script>
      // Handle redirects from 404.html for GitHub Pages SPA routing
      (function () {
        var redirect = sessionStorage.redirect;
        delete sessionStorage.redirect;
        if (redirect && redirect != location.href) {
          history.replaceState(null, null, redirect);
        }
      })();

      // Check if we need to handle query-based redirect from 404.html
      (function () {
        var l = window.location;
        if (l.search) {
          var q = {};
          l.search
            .slice(1)
            .split('&')
            .forEach(function (v) {
              var a = v.split('=');
              q[a[0]] = a.slice(1).join('=').replace(/~and~/g, '&');
            });
          if (q.p !== undefined) {
            // Remove the query parameter redirect and replace with the actual path
            var newUrl =
              l.protocol +
              '//' +
              l.hostname +
              (l.port ? ':' + l.port : '') +
              l.pathname +
              q.p +
              (q.q ? '?' + q.q : '') +
              l.hash;
            window.history.replaceState(null, null, newUrl);
          }
        }
      })();
    </script>

    <!-- SEO Meta Tags -->
    <title>STAC Explorer - Discover & Visualize Satellite Earth Observation Data</title>
    <meta
      name="description"
      content="Explore satellite imagery and Earth observation data from multiple STAC catalogs. Search, filter, and visualize geospatial datasets with our modern web interface."
    />
    <meta
      name="keywords"
      content="STAC, satellite imagery, earth observation, geospatial data, remote sensing, GIS, satellite data, planetary computer, sentinel, landsat"
    />
    <meta name="author" content="STAC Explorer" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="" id="canonical-url" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="" id="og-url" />
    <meta property="og:title" content="STAC Explorer - Discover Satellite Earth Observation Data" />
    <meta
      property="og:description"
      content="Modern web interface to explore satellite imagery and Earth observation data from multiple STAC catalogs. Search by location, time, and data type."
    />
    <meta property="og:image" content="" id="og-image" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="STAC Explorer" />
    <meta property="og:locale" content="en_US" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="" id="twitter-url" />
    <meta
      property="twitter:title"
      content="STAC Explorer - Discover Satellite Earth Observation Data"
    />
    <meta
      property="twitter:description"
      content="Modern web interface to explore satellite imagery and Earth observation data from multiple STAC catalogs."
    />
    <meta property="twitter:image" content="" id="twitter-image" />
    <meta property="twitter:creator" content="@your_twitter_handle" />

    <!-- Additional SEO -->
    <meta name="theme-color" content="#667eea" />
    <meta name="msapplication-TileColor" content="#667eea" />
    <meta name="application-name" content="STAC Explorer" />
    <meta name="apple-mobile-web-app-title" content="STAC Explorer" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />

    <!-- Early deep link detection script - must be before any CSS/assets -->
    <script>
      // Ultra-fast browser mode detection - runs immediately without waiting for DOM
      (function () {
        const path = window.location.pathname;
        const isBrowserMode = path.startsWith('/browser');

        if (isBrowserMode) {
          // Hide the page immediately to prevent flash
          document.documentElement.style.visibility = 'hidden';
          document.documentElement.style.opacity = '0';

          // Add browser-mode class to body for early styling
          document.documentElement.classList.add('browser-mode-loading');

          console.log('üöÄ Early browser mode detection - hiding page for fast loading:', path);

          // Set flag for later use in main app
          window.__STAC_EARLY_BROWSER_MODE = true;

          // Show only after our fast init is complete
          window.__STAC_SHOW_PAGE = function () {
            document.documentElement.style.visibility = 'visible';
            document.documentElement.style.opacity = '1';
            document.documentElement.style.transition = 'opacity 0.3s ease';
            document.documentElement.classList.remove('browser-mode-loading');
          };
        }
      })();
    </script>

    <!-- Minimal CSS for browser mode loading -->
    <style>
      .browser-mode-loading::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .browser-mode-loading::after {
        content: 'üöÄ Loading STAC Browser...';
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 1.2rem;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        z-index: 10000;
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }
    </style>

    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="preconnect" href="https://unpkg.com" />
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" />
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <!-- MapLibre GL CSS -->
    <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" />
    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <!-- Google Fonts - Roboto for Material Design -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <!-- Design Tokens - Load first for CSS custom properties -->
    <link rel="stylesheet" href="css/tokens/design-tokens.css" />
    <!-- Base Styles -->
    <link rel="stylesheet" href="css/base/animations.css" />
    <link rel="stylesheet" href="css/base/layout.css" />
    <link rel="stylesheet" href="css/base/components.css" />
    <!-- Theme System -->
    <link rel="stylesheet" href="css/themes/light-theme.css" />
    <link rel="stylesheet" href="css/themes/dark-theme.css" />
    <!-- Modern Glassmorphism CSS -->
    <link rel="stylesheet" href="css/styles.modern.css" />
    <!-- Extended Components -->
    <link rel="stylesheet" href="css/components/search-interface-extended.css" />
    <!-- Enhanced UI Components -->
    <link rel="stylesheet" href="css/components/buttons.css" />
    <link rel="stylesheet" href="css/components/modals.css" />
    <link rel="stylesheet" href="css/components/error-boundary.css" />
    <!-- Phase 2 UI Components -->
    <link rel="stylesheet" href="css/components/virtualized-list.css" />
    <link rel="stylesheet" href="css/components/loading-states.css" />
    <link rel="stylesheet" href="css/components/form-fields.css" />
    <link rel="stylesheet" href="css/components/notifications.css" />
    <link rel="stylesheet" href="css/components/command-palette.css" />
    <!-- Visualization Panel CSS -->
    <link rel="stylesheet" href="css/visualization-panel.css" />
    <!-- AI Button Styling -->
    <link rel="stylesheet" href="css/map-fix.css" />
    <!-- Filter System CSS -->
    <link rel="stylesheet" href="css/filter-system.css" />
    <!-- Collection Grid Selector -->
    <link rel="stylesheet" href="css/components/collection-grid.css" />
    <!-- Catalog Browser -->
    <link rel="stylesheet" href="css/components/catalog-browser.css" />
    <!-- Enhanced Modern Catalog Browser -->
    <link rel="stylesheet" href="css/components/catalog-browser-modern.css" />
    <!-- Enhanced Collection Cards -->
    <link rel="stylesheet" href="css/components/collection-cards-enhanced.css" />
    <!-- Simple Catalog Layout -->
    <link rel="stylesheet" href="css/components/catalog-simple.css" />
    <link rel="stylesheet" href="css/components/item-view-page.css" />
    <!-- Utilities -->
    <link rel="stylesheet" href="css/utils/utilities.css" />
    <!-- Deck.gl CSS - Note: Deck.gl doesn't require CSS for basic functionality -->
    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "STAC Explorer",
        "description": "Modern web interface to explore satellite imagery and Earth observation data from multiple STAC catalogs. Search, filter, and visualize geospatial datasets.",
        "url": "",
        "applicationCategory": "GeospatialApplication",
        "operatingSystem": "Web Browser",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "creator": {
          "@type": "Person",
          "name": "Nicolas Karasiak"
        },
        "keywords": [
          "STAC",
          "satellite imagery",
          "earth observation",
          "geospatial data",
          "remote sensing",
          "GIS",
          "satellite data",
          "planetary computer",
          "sentinel",
          "landsat"
        ],
        "screenshot": "",
        "datePublished": "2024-01-01",
        "dateModified": "2024-12-24",
        "inLanguage": "en-US",
        "isAccessibleForFree": true,
        "browser": ["Chrome", "Firefox", "Safari", "Edge"]
      }
    </script>
  </head>
  <body>
    <div class="app-container">
      <!-- Sidebar -->
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h1 id="app-logo" class="app-logo" title="Return to Homepage">
            <i class="material-icons">satellite_alt</i> <span>STAC Explorer</span>
          </h1>
          <div>
            <button id="browser-toggle" class="mode-toggle" title="Browse Catalogs">
              <i class="material-icons">web</i>
            </button>
            <button id="settings-toggle" class="settings-toggle" title="Settings">
              <i class="material-icons">settings</i>
            </button>
            <button id="theme-toggle" class="theme-toggle">
              <i class="material-icons">light_mode</i>
            </button>
          </div>
        </div>
        <div class="sidebar-content">
          <!-- Card-Based Search Container -->
          <div class="md-card" id="search-container">
            <div class="md-card-header" id="search-container-header">
              <h2 id="search-title"><i class="material-icons">search</i> Search</h2>
              <div class="header-actions">
                <!-- Deck.gl Status Indicator - Hidden, functionality moved to settings -->
                <div
                  class="search-history-dropdown hidden"
                  id="header-search-history"
                >
                  <button
                    id="header-search-history-btn"
                    class="header-action-btn"
                    title="Recent Searches"
                  >
                    <i class="material-icons">history</i>
                  </button>
                </div>
                <button
                  id="smart-filters-btn"
                  class="header-action-btn visible"
                  title="Data Filters"
                >
                  <i class="material-icons">tune</i>
                  <span id="filter-count-badge" class="filter-badge">0</span>
                </button>
                <button
                  id="load-stac-btn"
                  class="header-action-btn"
                  title="Load STAC item from URL or JSON"
                >
                  <i class="material-icons">file_download</i>
                </button>
              </div>
            </div>
            <div class="md-card-body">
              <!-- Beautiful Search Summary Interface -->
              <div class="search-summary-interface">
                <div class="search-summary-row">
                  <div
                    class="search-summary-item source-card-expanded"
                    id="summary-source"
                    data-field="collection"
                  >
                    <div class="source-card-main">
                      <div class="search-summary-content">
                        <div class="search-summary-label">SOURCE:</div>
                        <div class="search-summary-value">Select Source</div>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="search-summary-row">
                  <div
                    class="search-summary-item location-card-expanded"
                    id="summary-location"
                    data-field="location"
                  >
                    <div class="location-card-main">
                      <div class="search-summary-content">
                        <div class="search-summary-label">LOCATION:</div>
                        <div class="search-summary-value">
                          <div class="mini-location-input-container">
                            <input
                              type="text"
                              id="summary-location-input"
                              class="mini-location-input"
                              placeholder="Search city/country..."
                              value=""
                            />
                          </div>
                          <button
                            id="draw-bbox-inline"
                            class="location-action-btn"
                            title="Draw Area on Map"
                          >
                            <i class="material-icons">crop_free</i>
                            Draw
                          </button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="search-summary-row">
                  <div
                    class="search-summary-item time-card-expanded"
                    id="summary-date"
                    data-field="date"
                  >
                    <div class="time-card-main">
                      <div class="search-summary-content">
                        <div class="search-summary-label">TIME:</div>
                        <div class="search-summary-value">
                          <div class="mini-date-inputs" id="mini-date-container">
                            <input
                              type="text"
                              id="summary-start-date"
                              class="mini-date-input"
                              placeholder="YYYY-MM-DD"
                              maxlength="10"
                              value=""
                            />
                            <span class="date-separator">to</span>
                            <input
                              type="text"
                              id="summary-end-date"
                              class="mini-date-input"
                              placeholder="YYYY-MM-DD"
                              maxlength="10"
                              value=""
                            />
                          </div>
                          <script>
                            // Immediate date initialization and protection
                            (function () {
                              const today = new Date();
                              const oneMonthAgo = new Date(today);
                              oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);

                              const todayStr = today.toISOString().split('T')[0];
                              const oneMonthAgoStr = oneMonthAgo.toISOString().split('T')[0];

                              const startInput = document.getElementById('summary-start-date');
                              const endInput = document.getElementById('summary-end-date');

                              if (startInput && endInput) {
                                startInput.value = oneMonthAgoStr;
                                endInput.value = todayStr;
                                startInput.max = todayStr;
                                endInput.max = todayStr;

                                // Apply date format enforcement (will be defined later in the document)
                                setTimeout(() => {
                                  if (window.enforceDateFormat) {
                                    window.enforceDateFormat(startInput);
                                    window.enforceDateFormat(endInput);
                                  }
                                }, 100);
                              }

                              // Add mutation observer to restore date inputs if they get replaced
                              const summaryValueDiv = document.querySelector(
                                '[data-field="date"] .search-summary-value'
                              );
                              if (summaryValueDiv) {
                                const observer = new MutationObserver(mutations => {
                                  mutations.forEach(mutation => {
                                    if (
                                      mutation.type === 'childList' &&
                                      !summaryValueDiv.querySelector('.mini-date-inputs')
                                    ) {
                                      // Restore the mini date inputs
                                      summaryValueDiv.innerHTML = `
                                                                            <div class="mini-date-inputs" id="mini-date-container">
                                                                                <input type="text" id="summary-start-date" class="mini-date-input" placeholder="YYYY-MM-DD" maxlength="10" value="${oneMonthAgoStr}">
                                                                                <span class="date-separator">to</span>
                                                                                <input type="text" id="summary-end-date" class="mini-date-input" placeholder="YYYY-MM-DD" maxlength="10" value="${todayStr}">
                                                                            </div>
                                                                        `;

                                      // Setup simple date input listeners for restored inputs
                                      setTimeout(() => {
                                        const startInput =
                                          document.getElementById('summary-start-date');
                                        const endInput =
                                          document.getElementById('summary-end-date');
                                        if (startInput && endInput && window.searchSummaryManager) {
                                          window.searchSummaryManager.setupSimpleDateInputListeners(
                                            startInput
                                          );
                                          window.searchSummaryManager.setupSimpleDateInputListeners(
                                            endInput
                                          );
                                        }
                                      }, 50);
                                    }
                                  });
                                });
                                observer.observe(summaryValueDiv, {
                                  childList: true,
                                  subtree: true,
                                });
                              }
                            })();
                          </script>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Search Action Buttons -->
              <div class="search-actions">
                <button id="main-search-btn" class="md-btn md-btn-primary">
                  <i class="material-icons">search</i>
                  Search
                </button>
              </div>

              <!-- Hidden form inputs for compatibility with existing components -->
              <div class="hidden">
                <!-- Hidden card structures for component compatibility -->
                <div id="location-card">
                  <div class="search-card-body">
                    <div class="card-form-group"></div>
                  </div>
                </div>
                <div id="source-card"></div>
                <div id="dataset-card"></div>
                <div id="quality-card"></div>
                <div id="cloud-cover-controls"></div>
                <div id="global-summary">
                  <div class="summary-text">
                    <span id="summary-details">Browse Collections</span>
                  </div>
                </div>

                <!-- Form elements -->
                <select id="catalog-select" class="form-control">
                  <option value="">Auto-detect from selected dataset</option>
                  <!-- Options populated dynamically from collections.json -->
                  <option value="custom">‚öôÔ∏è Custom STAC Catalog</option>
                </select>
                <select id="collection-select" class="form-control">
                  <option value="">All datasets</option>
                </select>
                <input type="text" id="bbox-input" class="form-control" />
                <input type="date" id="date-start" class="form-control" />
                <input type="date" id="date-end" class="form-control" />
                <!-- Legacy cloud cover controls - hidden in favor of smart filter system -->
                <input type="checkbox" id="cloud-cover-enabled" class="hidden-checkbox" />
                <input
                  type="range"
                  id="cloud-cover"
                  min="0"
                  max="100"
                  value="20"
                  class="hidden"
                />
                <span id="cloud-cover-value" class="hidden">20%</span>
                <input type="text" id="custom-catalog-url" class="form-control" />
                <input type="text" id="collections" class="form-control" />
                <button id="connect-catalog-btn">Connect</button>
                <div id="custom-catalog-container"></div>
                <button id="criteria-draw-bbox-btn" class="js-hidden">Draw Area</button>
                <button id="collection-info-btn">Info</button>
                <button id="preset-2024">2024</button>
                <button id="summary-search-btn">Search</button>
                <button id="summary-reset-btn">Reset</button>
                <button id="execute-search">Execute Search</button>
                <button id="clear-all">Clear All</button>
                <input type="hidden" id="search-input" />
              </div>
            </div>
          </div>

          <!-- Results with pagination -->
          <div class="md-card results-card" id="results-card">
            <div class="md-card-header" id="results-header">
              <h2><i class="material-icons">list</i> Results</h2>
              <div class="header-content">
                <span id="results-count" class="md-badge">0</span>
                <i class="material-icons toggle-icon">expand_more</i>
              </div>
            </div>
            <div class="md-card-body">
              <ul id="dataset-list" class="dataset-list">
                <!-- Dataset items will be added here dynamically -->
              </ul>

              <!-- Pagination -->
              <div class="pagination">
                <button class="md-btn md-btn-secondary pagination-prev" disabled>
                  <i class="material-icons">navigate_before</i>
                </button>
                <span class="pagination-info"
                  >Page <span id="current-page">1</span> of <span id="total-pages">1</span></span
                >
                <button class="md-btn md-btn-secondary pagination-next" disabled>
                  <i class="material-icons">navigate_next</i>
                </button>
              </div>
            </div>
          </div>
        </div>
      </aside>

      <!-- Sidebar Toggle Button (outside sidebar so it's always visible) -->
      <div class="sidebar-toggle" id="sidebar-toggle">
        <i class="material-icons">chevron_left</i>
      </div>

      <!-- Map Container -->
      <main class="map-container">
        <div id="map"></div>

        <!-- Loading Indicator -->
        <div class="loading" id="loading">
          <div class="spinner"></div>
          <span>Loading data...</span>
        </div>

        <!-- Settings Panel (hidden by default) -->
        <div id="settings-panel" class="settings-panel">
          <div class="settings-header">
            <h2><i class="material-icons">settings</i> Settings</h2>
            <button class="settings-close-btn" id="settings-close-btn" title="Close Settings">
              <i class="material-icons">close</i>
            </button>
          </div>

          <div class="settings-content">
            <div class="settings-section">
              <h3><i class="material-icons">palette</i> Appearance</h3>
              <div class="setting-item">
                <div class="setting-content">
                  <div class="setting-label">Theme</div>
                  <div class="setting-description">Choose your preferred color theme</div>
                </div>
                <div class="setting-control">
                  <select id="theme-selector-panel" class="theme-selector">
                    <option value="auto">Auto (System)</option>
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="settings-section">
              <h3><i class="material-icons">speed</i> Performance</h3>
              <div class="setting-item">
                <div class="setting-content">
                  <div class="setting-label">GPU Acceleration</div>
                  <div class="setting-description">
                    Use Deck.gl for hardware-accelerated rendering when possible
                  </div>
                </div>
                <div class="setting-control">
                  <label class="toggle-switch">
                    <input type="checkbox" id="gpu-acceleration-toggle-panel" checked />
                    <span class="slider"></span>
                  </label>
                </div>
              </div>
              <div class="setting-status" id="gpu-status-display-panel">
                <i class="material-icons">info</i>
                <span id="gpu-status-text-panel">Checking GPU acceleration status...</span>
              </div>
            </div>

            <div class="settings-section">
              <h3><i class="material-icons">link</i> Custom Catalog</h3>
              <div class="setting-item">
                <div class="setting-content">
                  <div class="setting-label">STAC Catalog/API URL</div>
                  <div class="setting-description">
                    Enter the root URL of a STAC catalog or API endpoint
                  </div>
                </div>
                <div class="setting-control">
                  <div class="flex-gap-8">
                    <input
                      type="url"
                      id="custom-catalog-url"
                      class="settings-input custom-catalog-url-input"
                      placeholder="https://example.com/stac"
                    />
                    <button
                      id="add-custom-catalog-btn"
                      class="add-custom-catalog-btn"
                    >
                      Add
                    </button>
                  </div>
                </div>
              </div>
            </div>

            <div class="settings-section">
              <h3><i class="material-icons">storage</i> Data Catalogs</h3>
              <div class="setting-description-section">
                <p>
                  Enable or disable data catalogs for search. Disabled catalogs won't appear in
                  collection dropdowns.
                </p>
              </div>

              <!-- Collection toggles populated dynamically from collections.json -->
              <div id="catalog-toggles-panel-container"></div>
            </div>
          </div>
        </div>

        <!-- Browse Collections Panel (hidden by default) -->
        <div id="browse-collections-panel" class="browse-collections-panel">
          <div class="panel-header">
            <h2><i class="material-icons">dataset</i> Browse Collections</h2>
            <button
              class="panel-close-btn"
              id="browse-collections-close-btn"
              title="Close Browse Collections"
            >
              <i class="material-icons">close</i>
            </button>
          </div>

          <div class="panel-content" id="browse-collections-content">
            <!-- Collection browser content will be inserted here -->
          </div>
        </div>
      </main>
    </div>

    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <!-- Deck.gl JS -->
    <script src="https://unpkg.com/deck.gl@8.9.0/dist.min.js"></script>
    <!-- Flatpickr JS -->

    <!-- Enhanced Mobile Sidebar Manager -->
    <script type="module">
      /**
       * Enhanced Mobile Sidebar Manager
       * Hamburger menu only appears when sidebar is hidden
       */
      class MobileSidebarManager {
        constructor() {
          this.sidebar = null;
          this.backdrop = null;
          this.mobileMenuBtn = null;
          this.mobileCloseBtn = null;
          this.sidebarToggle = null;
          this.isDesktop = window.innerWidth > 768;
          this.isOpen = false;

          this.init();
          this.setupEventListeners();
        }

        init() {
          this.createMobileElements();
          this.sidebar = document.getElementById('sidebar');
          this.sidebarToggle = document.getElementById('sidebar-toggle');

          // Set initial state and icon based on current sidebar state
          this.updateLayout();
          this.setCorrectToggleIcon();
        }

        setCorrectToggleIcon() {
          if (!this.sidebarToggle) return;

          const toggleIcon = this.sidebarToggle.querySelector('i');
          if (!toggleIcon) return;

          if (this.isDesktop) {
            // On desktop, check sidebar state
            const isHidden = this.sidebar.classList.contains('hidden');
            toggleIcon.textContent = isHidden ? 'chevron_right' : 'chevron_left';
          }
        }

        createMobileElements() {
          // Create mobile hamburger menu button
          this.createMobileMenuButton();

          // Create backdrop overlay
          this.createBackdrop();

          // Add mobile close button to sidebar header
          this.addMobileCloseButton();
        }

        createMobileMenuButton() {
          this.mobileMenuBtn = document.createElement('button');
          this.mobileMenuBtn.className = 'mobile-menu-btn';
          this.mobileMenuBtn.innerHTML = '<i class="material-icons">menu</i>';
          this.mobileMenuBtn.setAttribute('aria-label', 'Open navigation menu');
          this.mobileMenuBtn.addEventListener('click', () => this.openSidebar());

          document.body.appendChild(this.mobileMenuBtn);
        }

        createBackdrop() {
          this.backdrop = document.createElement('div');
          this.backdrop.className = 'sidebar-backdrop';
          this.backdrop.addEventListener('click', () => this.closeSidebar());

          document.body.appendChild(this.backdrop);
        }

        addMobileCloseButton() {
          const sidebarHeader = document.querySelector('.sidebar-header');
          if (sidebarHeader) {
            this.mobileCloseBtn = document.createElement('button');
            this.mobileCloseBtn.className = 'mobile-close-btn';
            this.mobileCloseBtn.innerHTML = '<i class="material-icons">close</i>';
            this.mobileCloseBtn.setAttribute('aria-label', 'Close navigation menu');
            this.mobileCloseBtn.addEventListener('click', () => this.closeSidebar());

            sidebarHeader.appendChild(this.mobileCloseBtn);
          } else {
            console.error('Sidebar header not found!');
          }
        }

        setupEventListeners() {
          // Window resize handler
          window.addEventListener('resize', () => {
            const wasDesktop = this.isDesktop;
            this.isDesktop = window.innerWidth > 768;

            if (wasDesktop !== this.isDesktop) {
              this.updateLayout();
            }
          });

          // Listen for URL changes to update mobile toggle visibility
          window.addEventListener('popstate', () => {
            if (!this.isDesktop) {
              this.updateLayout();
            }
          });

          // Listen for pushstate events (programmatic navigation)
          const originalPushState = history.pushState;
          const originalReplaceState = history.replaceState;

          history.pushState = (...args) => {
            originalPushState.apply(history, args);
            if (!this.isDesktop) {
              setTimeout(() => this.updateLayout(), 100);
            }
          };

          history.replaceState = (...args) => {
            originalReplaceState.apply(history, args);
            if (!this.isDesktop) {
              setTimeout(() => this.updateLayout(), 100);
            }
          };

          // Existing desktop toggle
          if (this.sidebarToggle) {
            this.sidebarToggle.addEventListener('click', () => {
              if (this.isDesktop) {
                this.toggleDesktopSidebar();
              }
            });
          }

          // Keyboard navigation
          document.addEventListener('keydown', e => {
            if (e.key === 'Escape' && !this.isDesktop && this.isOpen) {
              this.closeSidebar();
            }
          });

          // Touch/swipe gestures (basic implementation)
          this.setupSwipeGestures();
        }

        setupSwipeGestures() {
          let startX = 0;
          let currentX = 0;
          let isSwipping = false;

          document.addEventListener(
            'touchstart',
            e => {
              if (!this.isDesktop) {
                startX = e.touches[0].clientX;
                isSwipping = true;
              }
            },
            { passive: true }
          );

          document.addEventListener(
            'touchmove',
            e => {
              if (!isSwipping || this.isDesktop) return;
              currentX = e.touches[0].clientX;
            },
            { passive: true }
          );

          document.addEventListener(
            'touchend',
            () => {
              if (!isSwipping || this.isDesktop) return;

              const diffX = currentX - startX;
              const threshold = 100;

              // Swipe right to open (from left edge)
              if (diffX > threshold && startX < 50 && !this.isOpen) {
                this.openSidebar();
              }

              // Swipe left to close (when sidebar is open)
              if (diffX < -threshold && this.isOpen) {
                this.closeSidebar();
              }

              isSwipping = false;
            },
            { passive: true }
          );
        }

        openSidebar() {
          if (this.isDesktop) return;

          this.isOpen = true;
          this.sidebar.classList.add('mobile-open');
          this.backdrop.classList.add('active');
          document.body.classList.add('sidebar-open');

          // Hide hamburger menu when sidebar is open
          this.mobileMenuBtn.style.display = 'none';

          // Show mobile close button when sidebar is open
          if (this.mobileCloseBtn) {
            this.mobileCloseBtn.style.display = 'flex';
          } else {
            console.error('No close button to show!');
          }

          // Update ARIA attributes
          this.sidebar.setAttribute('aria-hidden', 'false');

          // Focus first focusable element in sidebar
          setTimeout(() => {
            const firstFocusable = this.sidebar.querySelector(
              'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (firstFocusable && firstFocusable !== this.mobileCloseBtn) {
              firstFocusable.focus();
            } else if (this.mobileCloseBtn) {
              this.mobileCloseBtn.focus();
            }
          }, 100);
        }

        closeSidebar() {
          if (this.isDesktop) return;

          this.isOpen = false;
          this.sidebar.classList.remove('mobile-open');
          this.backdrop.classList.remove('active');
          document.body.classList.remove('sidebar-open');

          // Show hamburger menu when sidebar is closed
          this.mobileMenuBtn.style.display = 'flex';

          // Hide mobile close button when sidebar is closed
          if (this.mobileCloseBtn) {
            this.mobileCloseBtn.style.display = 'none';
          }

          // Update ARIA attributes
          this.sidebar.setAttribute('aria-hidden', 'true');

          // Return focus to menu button
          this.mobileMenuBtn.focus();
        }

        toggleDesktopSidebar() {
          if (!this.isDesktop) return;

          const isCurrentlyHidden = this.sidebar.classList.contains('hidden');

          if (isCurrentlyHidden) {
            // Show the sidebar
            this.sidebar.classList.remove('hidden');
            // Update toggle button icon to show it can hide
            const toggleIcon = this.sidebarToggle.querySelector('i');
            if (toggleIcon) {
              toggleIcon.textContent = 'chevron_left';
            }
          } else {
            // Hide the sidebar
            this.sidebar.classList.add('hidden');
            // Update toggle button icon to show it can show
            const toggleIcon = this.sidebarToggle.querySelector('i');
            if (toggleIcon) {
              toggleIcon.textContent = 'chevron_right';
            }
          }

          // Force a recompute
          setTimeout(() => {}, 100);
        }

        updateLayout() {
          if (this.isDesktop) {
            // Desktop layout
            this.closeSidebar(); // Close mobile sidebar if open
            this.sidebar.classList.remove('mobile-open');
            this.backdrop.classList.remove('active');
            document.body.classList.remove('sidebar-open');

            // Hide mobile elements
            this.mobileMenuBtn.style.display = 'none';
            if (this.mobileCloseBtn) {
              this.mobileCloseBtn.style.display = 'none';
            }

            // Show desktop toggle
            if (this.sidebarToggle) {
              this.sidebarToggle.style.display = 'flex';
            }

            // Update ARIA attributes
            this.sidebar.removeAttribute('aria-hidden');

            // Set correct toggle icon for desktop
            this.setCorrectToggleIcon();
          } else {
            // Mobile layout
            this.sidebar.classList.remove('collapsed'); // Remove desktop collapsed state
            this.sidebar.classList.remove('hidden'); // Remove desktop hidden state

            // Check if we should show mobile menu toggle based on current page
            const shouldShowMobileToggle = this.shouldShowMobileToggle();

            // Show/hide mobile hamburger menu based on page context
            this.mobileMenuBtn.style.display = shouldShowMobileToggle ? 'flex' : 'none';

            // Mobile close button visibility depends on sidebar state
            if (this.mobileCloseBtn) {
              this.mobileCloseBtn.style.display =
                this.isOpen && shouldShowMobileToggle ? 'flex' : 'none';
            }

            // Hide desktop toggle
            if (this.sidebarToggle) {
              this.sidebarToggle.style.display = 'none';
            }

            // Update ARIA attributes
            this.sidebar.setAttribute('aria-hidden', this.isOpen ? 'false' : 'true');
            if (shouldShowMobileToggle) {
              this.mobileMenuBtn.setAttribute('aria-expanded', this.isOpen ? 'true' : 'false');
            }
          }
        }

        /**
         * Determine if the mobile menu toggle should be shown
         * Hide the toggle when user is on the root/landing page (no URL parameters)
         * @returns {boolean} Whether to show the mobile toggle
         */
        shouldShowMobileToggle() {
          // Check if there are any URL parameters that indicate we're not on the landing page
          const urlParams = new URLSearchParams(window.location.search);
          const hasSearchParams = urlParams.toString().length > 0;

          // Check if there's a hash that indicates a specific view/state
          const hasHash = window.location.hash && window.location.hash.length > 1;

          // Show mobile toggle when there are URL parameters or hash (indicating user is in a specific view)
          // Hide mobile toggle on the landing page (no parameters)
          const shouldShow = hasSearchParams || hasHash;

          return shouldShow;
        }

        // Public API methods
        isMobile() {
          return !this.isDesktop;
        }

        isMobileSidebarOpen() {
          return !this.isDesktop && this.isOpen;
        }

        forceClose() {
          if (!this.isDesktop) {
            this.closeSidebar();
          }
        }
      }

      // Initialize mobile sidebar manager when DOM is loaded
      let mobileSidebarManager;

      document.addEventListener('DOMContentLoaded', () => {
        mobileSidebarManager = new MobileSidebarManager();

        // Export to global scope for debugging and external access
        window.mobileSidebarManager = mobileSidebarManager;
      });

      // Logo click handler - return to homepage
      document.addEventListener('DOMContentLoaded', () => {
        const appLogo = document.getElementById('app-logo');
        if (appLogo) {
          appLogo.addEventListener('click', () => {
            // Navigate to homepage (/viewer) - with correct base path
            const basePath =
              window.location.hostname.endsWith('.github.io') &&
              window.location.pathname.startsWith('/stacexplorer/')
                ? '/stacexplorer'
                : '';
            window.location.href = basePath + '/viewer';
          });
        }

        // Browser/Viewer mode toggle button handler
        const browserToggle = document.getElementById('browser-toggle');
        if (browserToggle) {
          // Detect current mode and extract path components
          const currentPath = window.location.pathname;
          const basePath =
            window.location.hostname.endsWith('.github.io') &&
            window.location.pathname.startsWith('/stacexplorer/')
              ? '/stacexplorer'
              : '';
          const isBrowserMode = currentPath.includes('/browser');

          // Update button appearance based on current mode
          const icon = browserToggle.querySelector('i');
          if (isBrowserMode) {
            // In browser mode, show viewer toggle
            icon.textContent = 'map';
            browserToggle.title = 'Switch to Map Viewer';
          } else {
            // In viewer mode, show browser toggle
            icon.textContent = 'web';
            browserToggle.title = 'Browse Catalogs';
          }

          browserToggle.addEventListener('click', () => {
            // Preserve query parameters and hash
            const queryString = window.location.search;
            const hash = window.location.hash;

            // Extract the path segments after the mode (browser/viewer)
            let pathSegments = '';

            if (isBrowserMode) {
              // Extract everything after /browser
              const browserIndex = currentPath.indexOf('/browser');
              if (browserIndex !== -1) {
                const afterBrowser = currentPath.substring(browserIndex + '/browser'.length);
                pathSegments = afterBrowser;
              }
              // Navigate to viewer mode preserving the path, query, and hash
              const newPath = pathSegments ? basePath + '/viewer' + pathSegments : basePath + '/';
              window.location.href = newPath + queryString + hash;
            } else {
              // Extract everything after /viewer, or from root if no /viewer
              const viewerIndex = currentPath.indexOf('/viewer');
              if (viewerIndex !== -1) {
                const afterViewer = currentPath.substring(viewerIndex + '/viewer'.length);
                pathSegments = afterViewer;
              } else {
                // Handle root path or other viewer paths - preserve any catalog/collection/item paths
                const withoutBase = currentPath.replace(basePath, '');
                if (withoutBase !== '/' && withoutBase !== '') {
                  // Remove leading slash if present
                  pathSegments = withoutBase.startsWith('/') ? withoutBase : '/' + withoutBase;
                }
              }
              // Navigate to browser mode preserving the path, query, and hash
              window.location.href = basePath + '/browser' + pathSegments + queryString + hash;
            }
          });
        }

        // Settings button handler - navigate to /settings with correct base path
        const settingsToggle = document.getElementById('settings-toggle');
        if (settingsToggle) {
          settingsToggle.addEventListener('click', () => {
            // Navigate to settings (/settings) - with correct base path
            const basePath =
              window.location.hostname.endsWith('.github.io') &&
              window.location.pathname.startsWith('/stacexplorer/')
                ? '/stacexplorer'
                : '';
            window.location.href = basePath + '/settings';
          });
        }

        // Dynamically set meta tag URLs based on current location
        const currentUrl = window.location.origin + window.location.pathname;
        // Use base path for static images
        const basePath =
          window.location.hostname.endsWith('.github.io') &&
          window.location.pathname.startsWith('/stacexplorer/')
            ? '/stacexplorer'
            : '';
        const imageUrl =
          window.location.origin + basePath + '/static/images/earthdaily_satellite.webp';

        // Update canonical URL
        const canonicalLink = document.getElementById('canonical-url');
        if (canonicalLink) canonicalLink.href = currentUrl;

        // Update Open Graph URLs
        const ogUrl = document.getElementById('og-url');
        if (ogUrl) ogUrl.content = currentUrl;

        const ogImage = document.getElementById('og-image');
        if (ogImage) ogImage.content = imageUrl;

        // Update Twitter URLs
        const twitterUrl = document.getElementById('twitter-url');
        if (twitterUrl) twitterUrl.content = currentUrl;

        const twitterImage = document.getElementById('twitter-image');
        if (twitterImage) twitterImage.content = imageUrl;

        // Update JSON-LD structured data
        const scriptTag = document.querySelector('script[type="application/ld+json"]');
        if (scriptTag) {
          try {
            const jsonData = JSON.parse(scriptTag.textContent);
            jsonData.url = currentUrl;
            jsonData.screenshot = imageUrl;
            scriptTag.textContent = JSON.stringify(jsonData, null, 2);
          } catch (e) {
            console.warn('Could not update JSON-LD structured data:', e);
          }
        }

        // Update sitemap.xml dynamically (for client-side processing)
        // Note: This won't affect the actual sitemap.xml file, but can help with dynamic content
        console.log('Dynamic URLs set for current location:', currentUrl);
      });
    </script>

    <!-- Load modules with ES modules -->
    <script type="module" src="src/main.js"></script>

    <!-- Direct fix for the Draw Bounding Box button -->
    <script>
      console.log('üü¢ SCRIPT BLOCK STARTED - JavaScript is working');
      // Wait for the application to be fully loaded
      document.addEventListener('DOMContentLoaded', function () {
        // Wait a bit more to ensure all components are initialized
        setTimeout(function () {
          // Get the button (now it's hidden but still needs to work)
          const criteriaBboxBtn = document.getElementById('criteria-draw-bbox-btn');

          if (criteriaBboxBtn) {
            // Remove any existing event listeners
            const newBtn = criteriaBboxBtn.cloneNode(true);
            criteriaBboxBtn.parentNode.replaceChild(newBtn, criteriaBboxBtn);

            // Add a new event listener
            newBtn.addEventListener('click', function () {
              console.log('üéØ Hidden Draw button clicked!');
              if (window.stacExplorer && window.stacExplorer.mapManager) {
                console.log('‚úÖ Map manager found, starting drawing mode');
                // Access the map manager directly
                const mapManager = window.stacExplorer.mapManager;

                // Start drawing mode
                console.log('üñäÔ∏è Calling startDrawingBbox()');
                mapManager.startDrawingBbox();
              } else {
                console.error('‚ùå Map manager not available');
                console.log('üîç window.stacExplorer:', window.stacExplorer);
              }
            });
          } else {
            console.error('Could not find the criteria-draw-bbox-btn element');
          }

          // Note: Preset button handlers are now initialized in the main DOMContentLoaded section

          // Set up collection info button
          const collectionInfoBtn = document.getElementById('collection-info-btn');
          if (collectionInfoBtn) {
            collectionInfoBtn.addEventListener('click', function () {
              // This can be a no-op since the inline AI search handles collection details
            });
          }

          // Set up visible date preset buttons
          // setupDatePresetButtons(); // Disabled - using new inline date input system

          // Set up source preset buttons
          setupSourcePresetButtons();

          // Set up visible drawing and info tools
          console.log('üöÄ About to call setupVisibleTools()');
          setupVisibleTools();
          console.log('‚úÖ setupVisibleTools() called');
          
          // Manual fallback test
          console.log('üîß Trying manual button setup...');
          const manualBtn = document.getElementById('draw-bbox-inline');
          if (manualBtn) {
            console.log('‚úÖ Manual button found, adding direct listener');
            
            // Test programmatic click
            window.testDrawButtonClick = function() {
              console.log('üß™ Testing programmatic click');
              manualBtn.click();
            };
            
            manualBtn.onclick = function() {
              console.log('üéâ MANUAL CLICK WORKED!');
              alert('Draw button clicked manually!');
            };
            
            console.log('üß™ Added window.testDrawButtonClick() function for testing');
          } else {
            console.log('‚ùå Manual button not found');
          }
        }, 1000); // Wait 1 second to ensure everything is loaded
      });

      // OLD Date Preset Button Setup - DISABLED
      // This function is disabled in favor of the new inline date input system
      function setupDatePresetButtons() {
        // Old preset button handlers are disabled
        // New handlers are initialized in the DOMContentLoaded section below
      }

      // Source Preset Button Setup
      function setupSourcePresetButtons() {
        const sourceButtons = document.querySelectorAll('.source-mini-btn');

        sourceButtons.forEach(button => {
          button.addEventListener('click', function (e) {
            e.stopPropagation(); // Prevent triggering the parent click

            const collection = this.getAttribute('data-collection');
            const buttonId = this.id;

            if (buttonId === 'source-more') {
              // Handle "+" button - open the source dropdown
              const summarySource = document.getElementById('summary-source');
              if (summarySource) {
                // Trigger the dropdown by simulating a click on the source card
                summarySource.click();
              }
              return;
            }

            if (collection) {
              // Remove active class from all source preset buttons
              sourceButtons.forEach(btn => {
                if (btn.id !== 'source-more') {
                  btn.classList.remove('active');
                }
              });
              // Add active class to clicked button
              this.classList.add('active');

              // Select the collection in the hidden dropdown
              setSelectedCollection(collection);

              // Update the search summary display
              updateSourceSummaryDisplay(this.textContent, this.title);
            }
          });
        });
      }

      // Set selected collection in hidden form
      function setSelectedCollection(collectionId) {
        const collectionSelect = document.getElementById('collection-select');
        if (collectionSelect) {
          // Find option with matching value or create one if it doesn't exist
          let option = Array.from(collectionSelect.options).find(opt => opt.value === collectionId);

          if (!option) {
            // Create a new option for this collection ID
            option = new Option(collectionId, collectionId);
            collectionSelect.appendChild(option);
          }

          collectionSelect.value = collectionId;
          collectionSelect.dispatchEvent(new Event('change'));
        }
      }

      // Update source summary display
      function updateSourceSummaryDisplay(buttonText, fullName) {
        const sourceValueElement = document.querySelector(
          '.search-summary-item:has(.search-summary-label:contains("Source")) .search-summary-value'
        );
        if (!sourceValueElement) {
          // Alternative selector if :has() is not supported
          const sourceItems = document.querySelectorAll('.search-summary-item');
          for (const item of sourceItems) {
            const label = item.querySelector('.search-summary-label');
            if (label && label.textContent.includes('Source')) {
              const valueElement = item.querySelector('.search-summary-value');
              if (valueElement) {
                valueElement.textContent = `üõ∞Ô∏è ${fullName}`;
                break;
              }
            }
          }
        } else {
          sourceValueElement.textContent = `üõ∞Ô∏è ${fullName}`;
        }
      }

      // Set date range for last N days
      function setDateRange(days) {
        const today = new Date();
        const startDate = new Date(today);
        startDate.setDate(today.getDate() - days);

        const startDateStr = startDate.toISOString().split('T')[0];
        const endDateStr = today.toISOString().split('T')[0];

        // Update mini date inputs (new system)
        const summaryStartInput = document.getElementById('summary-start-date');
        const summaryEndInput = document.getElementById('summary-end-date');
        if (summaryStartInput) summaryStartInput.value = startDateStr;
        if (summaryEndInput) summaryEndInput.value = endDateStr;

        // Update hidden form inputs (for compatibility)
        const formStartInput = document.getElementById('date-start');
        const formEndInput = document.getElementById('date-end');
        if (formStartInput) formStartInput.value = startDateStr;
        if (formEndInput) formEndInput.value = endDateStr;

        // Trigger search parameter change event
        document.dispatchEvent(
          new CustomEvent('searchParameterChanged', {
            detail: {
              type: 'date',
              dateType: 'custom',
              dateStart: startDateStr,
              dateEnd: endDateStr,
            },
          })
        );
      }

      // Set date range for a specific year
      function setYearRange(year) {
        const startDateStr = `${year}-01-01`;
        let endDateStr;

        // If it's the current year, use today's date as end date
        const currentYear = new Date().getFullYear();
        if (year === currentYear) {
          endDateStr = new Date().toISOString().split('T')[0];
        } else {
          endDateStr = `${year}-12-31`;
        }

        // Update mini date inputs (new system)
        const summaryStartInput = document.getElementById('summary-start-date');
        const summaryEndInput = document.getElementById('summary-end-date');
        if (summaryStartInput) summaryStartInput.value = startDateStr;
        if (summaryEndInput) summaryEndInput.value = endDateStr;

        // Update hidden form inputs (for compatibility)
        const formStartInput = document.getElementById('date-start');
        const formEndInput = document.getElementById('date-end');
        if (formStartInput) formStartInput.value = startDateStr;
        if (formEndInput) formEndInput.value = endDateStr;

        // Trigger search parameter change event
        document.dispatchEvent(
          new CustomEvent('searchParameterChanged', {
            detail: {
              type: 'date',
              dateType: 'custom',
              dateStart: startDateStr,
              dateEnd: endDateStr,
            },
          })
        );
      }

      // Update the search summary display with current date selection
      function updateSearchSummaryDisplay() {
        const startDate = document.getElementById('date-start').value;
        const endDate = document.getElementById('date-end').value;
        const summaryDateElement = document.querySelector('#summary-date .search-summary-value');

        if (startDate && endDate) {
          const start = new Date(startDate);
          const end = new Date(endDate);
          const today = new Date();

          // Format dates nicely
          const startStr = start.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric',
          });
          const endStr = end.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric',
          });

          // Check for common presets
          const daysDiff = Math.round((end - start) / (1000 * 60 * 60 * 24));
          const todayStr = today.toISOString().split('T')[0];
          const endStr2 = end.toISOString().split('T')[0];

          let displayText;
          if (endStr2 === todayStr && daysDiff === 6) {
            displayText = 'üìÖ Last 7 Days';
          } else if (endStr2 === todayStr && daysDiff === 29) {
            displayText = 'üìÖ Last 30 Days';
          } else if (startDate.endsWith('-01-01') && endDate.endsWith('-12-31')) {
            const year = startDate.split('-')[0];
            displayText = `üìÖ Year ${year}`;
          } else {
            displayText = `üìÖ ${startStr} - ${endStr}`;
          }

          if (summaryDateElement) {
            summaryDateElement.textContent = displayText;
          }
        }
      }

      // Setup visible drawing and info tools
      function setupVisibleTools() {
        // Inline draw bbox button in location card
        const inlineDrawBtn = document.getElementById('draw-bbox-inline');
        const hiddenDrawBtn = document.getElementById('criteria-draw-bbox-btn');

        console.log('üîß Setting up visible tools...');
        console.log('üîç Inline draw button found:', !!inlineDrawBtn);
        console.log('üîç Hidden draw button found:', !!hiddenDrawBtn);

        if (inlineDrawBtn && hiddenDrawBtn) {
          console.log('‚úÖ Both buttons found, setting up event listener');
          
          // Define the click handler function
          const drawClickHandler = function (e) {
            console.log('üëÜ DRAW BUTTON CLICK INTERCEPTED!', e);
            console.log('üëÜ Event target:', e.target);
            console.log('üëÜ Current target:', e.currentTarget);
            
            try {
              e.preventDefault(); // Prevent default behavior
              e.stopPropagation(); // Prevent triggering the parent card click
              e.stopImmediatePropagation(); // Stop all other handlers

              // Trigger the hidden button's functionality
              console.log('üéØ Triggering hidden button click');
              console.log('üéØ Hidden button element:', hiddenDrawBtn);
              hiddenDrawBtn.click();

              // Visual feedback
              console.log('üé® Applying visual feedback');
              this.style.background = 'var(--primary-500, #2196F3)';
              this.style.color = 'white';
              setTimeout(() => {
                this.style.background = '';
                this.style.color = '';
                console.log('üé® Visual feedback reset');
              }, 2000);
              
              return false; // Additional prevention
            } catch (error) {
              console.error('‚ùå Error in click handler:', error);
            }
          };
          
          // Add multiple event listeners with different approaches
          inlineDrawBtn.addEventListener('click', drawClickHandler, true); // Capture phase
          inlineDrawBtn.addEventListener('click', drawClickHandler, false); // Bubble phase
          inlineDrawBtn.onclick = drawClickHandler; // DOM0 event handler
          
          // Set tabindex to make it focusable and handle other events
          inlineDrawBtn.setAttribute('tabindex', '0');
          
          console.log('‚úÖ Multiple event listeners added to inline draw button');
        } else {
          console.error('‚ùå Could not find both draw buttons');
        }

      }

      // Enhanced Search Interface Management
      function setupEnhancedSearchInterface() {
        // Set up clickable search summary items
        setupSearchSummaryItems();

        // Set up result count preview
        setupResultCountPreview();
      }

      // Setup clickable search summary items
      function setupSearchSummaryItems() {
        const summaryItems = document.querySelectorAll(
          '.search-summary-item:not(.location-card-expanded):not(.time-card-expanded)'
        );

        summaryItems.forEach(item => {
          item.addEventListener('click', function () {
            const field = this.getAttribute('data-field');

            if (field === 'collection') {
              // Trigger the source dropdown from the inline dropdown system
              const summarySource = document.getElementById('summary-source');
              if (summarySource) {
                summarySource.click();
              }
            }
          });
        });
      }

      // Initialize the beautiful GeocodingService and map preview
      let geocodingService;
      let mapPreviewHandler = null;
      let originalMapView = null;
      let previewLayer = null;

      async function initializeGeocodingService() {
        try {
          // Import the beautiful GeocodingService
          const { defaultGeocodingService } = await import('/js/utils/GeocodingService.js');
          geocodingService = defaultGeocodingService;
          // Make it globally available
          window.geocodingService = defaultGeocodingService;

          // Initialize map preview functionality
          initializeMapPreview();
        } catch (error) {
          console.error(
            '‚ùå Failed to load GeocodingService, falling back to simple implementation'
          );
          geocodingService = null;
          window.geocodingService = null;
        }
      }

      // Make the function globally available
      window.initializeGeocodingService = initializeGeocodingService;

      // Initialize map preview functionality
      function initializeMapPreview() {
        // Wait for map to be available
        setTimeout(() => {
          if (
            window.stacExplorer &&
            window.stacExplorer.mapManager &&
            window.stacExplorer.mapManager.map
          ) {
            mapPreviewHandler = new LocationMapPreview(window.stacExplorer.mapManager.map);
          } else {
            initializeMapPreview(); // Retry
          }
        }, 1000);
      }

      // Location Map Preview Handler Class
      class LocationMapPreview {
        constructor(map) {
          this.map = map;
          this.originalView = null;
          this.previewSourceId = 'location-preview';
          this.previewLayerId = 'location-preview-layer';
          this.isPreviewActive = false;
          this.hasStoredOriginalView = false;
        }

        // Store the original view when search starts (before any hover)
        storeOriginalView() {
          if (!this.hasStoredOriginalView && this.map) {
            this.originalView = {
              center: this.map.getCenter(),
              zoom: this.map.getZoom(),
              bearing: this.map.getBearing(),
              pitch: this.map.getPitch(),
            };
            this.hasStoredOriginalView = true;
          }
        }

        // Reset the stored view (call when search ends)
        resetStoredView() {
          this.originalView = null;
          this.hasStoredOriginalView = false;
        }

        // Show location preview on map
        showLocationPreview(result) {
          if (!this.map || this.isPreviewActive) return;

          this.isPreviewActive = true;

          // Store original view if not already stored
          this.storeOriginalView();

          // Create GeoJSON for the location
          const geoJson = this.createLocationGeoJSON(result);

          // Add preview layer to map
          this.addPreviewLayer(geoJson);

          // Zoom to location
          this.zoomToLocation(result);
        }

        // Hide location preview
        hideLocationPreview() {
          if (!this.map || !this.isPreviewActive) return;

          this.isPreviewActive = false;

          // Remove preview layer
          this.removePreviewLayer();

          // Restore original view with smooth transition
          if (this.originalView) {
            this.map.easeTo({
              center: this.originalView.center,
              zoom: this.originalView.zoom,
              bearing: this.originalView.bearing,
              pitch: this.originalView.pitch,
              duration: 500,
              essential: false,
            });
          }
        }

        // Create GeoJSON from location result
        createLocationGeoJSON(result) {
          const features = [];

          // Add point feature
          features.push({
            type: 'Feature',
            properties: {
              type: 'point',
              name: result.name || result.shortName,
              category: result.category,
            },
            geometry: {
              type: 'Point',
              coordinates: [result.lon, result.lat],
            },
          });

          // Add bounding box feature if available
          if (result.bbox && result.bbox.length === 4) {
            const [west, south, east, north] = result.bbox;
            features.push({
              type: 'Feature',
              properties: {
                type: 'bbox',
                name: result.name || result.shortName,
                category: result.category,
              },
              geometry: {
                type: 'Polygon',
                coordinates: [
                  [
                    [west, south],
                    [east, south],
                    [east, north],
                    [west, north],
                    [west, south],
                  ],
                ],
              },
            });
          }

          return {
            type: 'FeatureCollection',
            features: features,
          };
        }

        // Add preview layer to map
        addPreviewLayer(geoJson) {
          // Remove existing preview layer if any
          this.removePreviewLayer();

          // Add source
          this.map.addSource(this.previewSourceId, {
            type: 'geojson',
            data: geoJson,
          });

          // Add polygon fill layer (for bbox)
          this.map.addLayer({
            id: this.previewLayerId + '-fill',
            type: 'fill',
            source: this.previewSourceId,
            filter: ['==', ['get', 'type'], 'bbox'],
            paint: {
              'fill-color': '#2196F3',
              'fill-opacity': 0.1,
            },
          });

          // Add polygon outline layer (for bbox)
          this.map.addLayer({
            id: this.previewLayerId + '-outline',
            type: 'line',
            source: this.previewSourceId,
            filter: ['==', ['get', 'type'], 'bbox'],
            paint: {
              'line-color': '#2196F3',
              'line-width': 2,
              'line-opacity': 0.8,
            },
          });

          // Add point layer
          this.map.addLayer({
            id: this.previewLayerId + '-point',
            type: 'circle',
            source: this.previewSourceId,
            filter: ['==', ['get', 'type'], 'point'],
            paint: {
              'circle-color': '#2196F3',
              'circle-radius': 8,
              'circle-stroke-color': '#ffffff',
              'circle-stroke-width': 2,
              'circle-opacity': 0.9,
            },
          });
        }

        // Remove preview layer from map
        removePreviewLayer() {
          const layerIds = [
            this.previewLayerId + '-fill',
            this.previewLayerId + '-outline',
            this.previewLayerId + '-point',
          ];

          layerIds.forEach(layerId => {
            if (this.map.getLayer(layerId)) {
              this.map.removeLayer(layerId);
            }
          });

          if (this.map.getSource(this.previewSourceId)) {
            this.map.removeSource(this.previewSourceId);
          }
        }

        // Zoom map to location
        zoomToLocation(result) {
          if (result.bbox && result.bbox.length === 4) {
            // Use bbox for zoom
            const [west, south, east, north] = result.bbox;
            this.map.fitBounds(
              [
                [west, south],
                [east, north],
              ],
              {
                padding: 50,
                duration: 800,
                essential: false,
              }
            );
          } else {
            // Use point location with appropriate zoom based on category
            const zoomLevels = {
              country: 5,
              state: 7,
              city: 11,
              town: 13,
              village: 15,
              address: 17,
            };
            const zoom = zoomLevels[result.category] || 12;

            this.map.easeTo({
              center: [result.lon, result.lat],
              zoom: zoom,
              duration: 800,
              essential: false,
            });
          }
        }
      }

      // Search locations using the beautiful GeocodingService
      async function searchLocations(query, container) {
        if (!geocodingService) {
          // Fallback to simple implementation
          return searchLocationsSimple(query, container);
        }

        try {
          // Use the beautiful geocoding service
          geocodingService.searchLocations(query, (results, error) => {
            if (error) {
              console.error('Beautiful geocoding error:', error);
              container.innerHTML =
                '<div class="suggestion-item">Search temporarily unavailable</div>';
              container.classList.add('active');
              return;
            }

            displayBeautifulLocationSuggestions(results, container);
          });
        } catch (error) {
          console.error('Location search error:', error);
          container.innerHTML = '<div class="suggestion-item">Search temporarily unavailable</div>';
          container.classList.add('active');
        }
      }

      // Simple fallback implementation
      async function searchLocationsSimple(query, container) {
        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`
          );
          const results = await response.json();

          displayLocationSuggestions(results, container);
        } catch (error) {
          console.error('Location search error:', error);
          container.innerHTML = '<div class="suggestion-item">Search temporarily unavailable</div>';
          container.classList.add('active');
        }
      }

      // Display beautiful location suggestions using processed results
      function displayBeautifulLocationSuggestions(results, container) {
        if (results.length === 0) {
          container.innerHTML = '<div class="suggestion-item">No locations found</div>';
          container.classList.add('active');
          return;
        }

        // Sort by relevance score (higher is better)
        const sortedResults = results.sort(
          (a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0)
        );

        const html = sortedResults
          .map(result => {
            const categoryIcons = {
              country: 'public',
              state: 'location_city',
              city: 'location_city',
              town: 'location_on',
              village: 'home',
              administrative: 'account_balance',
              natural: 'landscape',
              address: 'place',
            };

            const icon = categoryIcons[result.category] || 'place';
            const shortName = result.shortName || result.name;
            const details =
              result.formattedName !== result.name
                ? result.formattedName.replace(result.name + ', ', '')
                : result.address?.country || '';

            return `
                    <div class="suggestion-item" 
                         data-lat="${result.lat}" 
                         data-lon="${result.lon}" 
                         data-name="${shortName}"
                         data-bbox="${result.bbox ? result.bbox.join(',') : ''}"
                         data-category="${result.category}">
                        <i class="material-icons">${icon}</i>
                        <div class="suggestion-content">
                            <div class="suggestion-name">${shortName}</div>
                            <div class="suggestion-details">${details}</div>
                        </div>
                    </div>
                `;
          })
          .join('');

        container.innerHTML = html;
        container.classList.add('active');

        // Add click and hover handlers to suggestions
        container.querySelectorAll('.suggestion-item').forEach((item, index) => {
          const result = sortedResults[index];

          item.addEventListener('click', function (e) {
            e.stopPropagation(); // Prevent triggering dropdown menu
            selectBeautifulLocation(this);
          });

          // Add hover preview functionality
          item.addEventListener('mouseenter', function () {
            if (mapPreviewHandler && result) {
              this.classList.add('map-preview-active');
              mapPreviewHandler.showLocationPreview(result);
            }
          });

          item.addEventListener('mouseleave', function () {
            if (mapPreviewHandler) {
              this.classList.remove('map-preview-active');
              mapPreviewHandler.hideLocationPreview();
            }
          });
        });
      }

      // Simple fallback display
      function displayLocationSuggestions(results, container) {
        if (results.length === 0) {
          container.innerHTML = '<div class="suggestion-item">No locations found</div>';
          container.classList.add('active');
          return;
        }

        const html = results
          .map(result => {
            const name = result.display_name.split(',')[0];
            const details = result.display_name.split(',').slice(1, 3).join(',').trim();

            return `
                    <div class="suggestion-item" data-lat="${result.lat}" data-lon="${result.lon}" data-name="${name}">
                        <i class="material-icons">place</i>
                        <div class="suggestion-content">
                            <div class="suggestion-name">${name}</div>
                            <div class="suggestion-details">${details}</div>
                        </div>
                    </div>
                `;
          })
          .join('');

        container.innerHTML = html;
        container.classList.add('active');

        // Add click and hover handlers to suggestions
        container.querySelectorAll('.suggestion-item').forEach((item, index) => {
          const result = results[index];

          item.addEventListener('click', function (e) {
            e.stopPropagation(); // Prevent triggering dropdown menu
            selectLocation(this);
          });

          // Add basic hover preview functionality
          item.addEventListener('mouseenter', function () {
            if (mapPreviewHandler && result) {
              this.classList.add('map-preview-active');
              // Convert simple result to compatible format
              const compatibleResult = {
                lat: parseFloat(result.lat),
                lon: parseFloat(result.lon),
                name: result.display_name.split(',')[0],
                shortName: result.display_name.split(',')[0],
                category: 'place',
                bbox: result.boundingbox
                  ? [
                      parseFloat(result.boundingbox[2]), // west
                      parseFloat(result.boundingbox[0]), // south
                      parseFloat(result.boundingbox[3]), // east
                      parseFloat(result.boundingbox[1]), // north
                    ]
                  : null,
              };
              mapPreviewHandler.showLocationPreview(compatibleResult);
            }
          });

          item.addEventListener('mouseleave', function () {
            if (mapPreviewHandler) {
              this.classList.remove('map-preview-active');
              mapPreviewHandler.hideLocationPreview();
            }
          });
        });
      }

      // Select a beautiful location with enhanced data
      function selectBeautifulLocation(suggestionElement) {
        const lat = parseFloat(suggestionElement.getAttribute('data-lat'));
        const lon = parseFloat(suggestionElement.getAttribute('data-lon'));
        const name = suggestionElement.getAttribute('data-name');
        const bboxStr = suggestionElement.getAttribute('data-bbox');
        const category = suggestionElement.getAttribute('data-category');

        let bbox;
        if (bboxStr && bboxStr !== '') {
          // Use the precise bounding box from the geocoding service
          bbox = bboxStr;
        } else {
          // Fallback: create a buffer based on location category
          const buffers = {
            country: 2.0,
            state: 1.0,
            city: 0.1,
            town: 0.05,
            village: 0.02,
            address: 0.001,
          };
          const buffer = buffers[category] || 0.1;

          bbox = [lon - buffer, lat - buffer, lon + buffer, lat + buffer].join(',');
        }

        // Update the hidden bbox input
        const bboxInput = document.getElementById('bbox-input');
        if (bboxInput) {
          bboxInput.value = bbox;
          bboxInput.dispatchEvent(new Event('change'));
        }

        // Category icons for display
        const categoryEmojis = {
          country: 'üåç',
          state: 'üèõÔ∏è',
          city: 'üèôÔ∏è',
          town: 'üèòÔ∏è',
          village: 'üè°',
          administrative: 'üìç',
          natural: 'üèîÔ∏è',
          address: 'üìç',
        };

        const emoji = categoryEmojis[category] || 'üìç';

        // Update the search summary display
        const summaryLocationElement = document.querySelector(
          '#summary-location .search-summary-value'
        );
        if (summaryLocationElement) {
          summaryLocationElement.textContent = `${emoji} ${name}`;
        }

        // Keep current map view when location is selected
        if (mapPreviewHandler) {
          mapPreviewHandler.hideLocationPreview();
          // Don't reset the stored view - keep current position
        }

        // Show result count if possible
        updateResultCountPreview();
      }

      // Fallback select function for simple results
      function selectLocation(suggestionElement) {
        const lat = parseFloat(suggestionElement.getAttribute('data-lat'));
        const lon = parseFloat(suggestionElement.getAttribute('data-lon'));
        const name = suggestionElement.getAttribute('data-name');

        // Create a bounding box around the location (roughly 0.1 degree buffer)
        const buffer = 0.1;
        const bbox = [lon - buffer, lat - buffer, lon + buffer, lat + buffer].join(',');

        // Update the hidden bbox input
        const bboxInput = document.getElementById('bbox-input');
        if (bboxInput) {
          bboxInput.value = bbox;
          bboxInput.dispatchEvent(new Event('change'));
        }

        // Update the search summary display
        const summaryLocationElement = document.querySelector(
          '#summary-location .search-summary-value'
        );
        if (summaryLocationElement) {
          summaryLocationElement.textContent = `üìç ${name}`;
        }

        // Keep current map view when location is selected
        if (mapPreviewHandler) {
          mapPreviewHandler.hideLocationPreview();
          // Don't reset the stored view - keep current position
        }

        // Show result count if possible
        updateResultCountPreview();
      }

      // Setup result count preview
      function setupResultCountPreview() {
        const searchBtn = document.getElementById('main-search-btn');

        // Add result count badge to search button
        if (searchBtn && !searchBtn.querySelector('.result-count-badge')) {
          const badge = document.createElement('span');
          badge.className = 'result-count-badge';
          badge.style.display = 'none';
          badge.innerHTML = '<i class="material-icons">search</i><span class="count">0</span>';
          searchBtn.appendChild(badge);
        }
      }

      // Update result count preview (placeholder - would integrate with actual search)
      function updateResultCountPreview() {
        // This would integrate with your actual search system
        // For now, just show a placeholder
        setTimeout(() => {
          const badge = document.querySelector('.result-count-badge');
          if (badge) {
            const countSpan = badge.querySelector('.count');
            if (countSpan) {
              // Simulate getting a count
              const simulatedCount = Math.floor(Math.random() * 500) + 50;
              countSpan.textContent = simulatedCount;
              badge.style.display = 'inline-flex';

              setTimeout(() => {
                badge.style.display = 'none';
              }, 3000);
            }
          }
        }, 500);
      }

      // Initialize everything when page loads
      document.addEventListener('DOMContentLoaded', function () {
        console.log('üìÑ DOM Content Loaded');
        
        // Test if buttons exist immediately
        const testInlineBtn = document.getElementById('draw-bbox-inline');
        const testHiddenBtn = document.getElementById('criteria-draw-bbox-btn');
        console.log('üß™ Early test - Inline button exists:', !!testInlineBtn);
        console.log('üß™ Early test - Hidden button exists:', !!testHiddenBtn);
        
        // Initialize the beautiful geocoding service first
        initializeGeocodingService();

        // Wait for app to be ready then set up enhanced functionality
        setTimeout(() => {
          updateSearchSummaryDisplay(); // Update initial display
          setupEnhancedSearchInterface(); // Setup enhanced search features
        }, 2000);
      });

      // Fix collection details modal to prevent scrolling issues
      document.addEventListener('DOMContentLoaded', function () {
        // Force hide any existing modal overlay
        const modalOverlay = document.getElementById('collection-details-modal');
        if (modalOverlay) {
          modalOverlay.style.display = 'none';
          modalOverlay.classList.remove('active');
        }

        // Ensure body doesn't have modal-open class
        document.body.classList.remove('modal-open');

        // Global function to force YYYY-MM-DD format on date inputs
        window.enforceDateFormat = function (inputElement) {
          if (inputElement && inputElement.type === 'date') {
            // Set locale-specific attributes
            inputElement.setAttribute('lang', 'en-US');
            inputElement.setAttribute('data-format', 'yyyy-mm-dd');

            // Force text direction
            inputElement.style.direction = 'ltr';
            inputElement.style.unicodeBidi = 'embed';

            // Try to force the locale through JavaScript
            // This creates a hidden date input to check browser behavior
            const testDate = new Date('2025-01-15');
            const expectedFormat = '2025-01-15';
            inputElement.setAttribute('data-expected-format', expectedFormat);

            // Add event listener to ensure value stays in correct format
            inputElement.addEventListener('input', function (e) {
              // The browser should automatically handle this, but we can add validation
              const value = e.target.value;
              if (value && !/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                console.warn('Date input format may not be YYYY-MM-DD:', value);
              }
            });
          }
        };

        // Initialize date input handlers with retry logic
        const initializeDateInputs = () => {
          const startDateInput = document.getElementById('summary-start-date');
          const endDateInput = document.getElementById('summary-end-date');

          if (!startDateInput || !endDateInput) {
            // Try again in 100ms if inputs don't exist yet
            setTimeout(initializeDateInputs, 100);
            return;
          }

          // Initialize with default values (today and one month ago)
          const today = new Date();
          const oneMonthAgo = new Date(today);
          oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);

          const todayStr = today.toISOString().split('T')[0];
          const oneMonthAgoStr = oneMonthAgo.toISOString().split('T')[0];

          startDateInput.value = oneMonthAgoStr;
          endDateInput.value = todayStr;
          startDateInput.max = todayStr;
          endDateInput.max = todayStr;

          // Also update the form inputs immediately
          const formStartInput = document.getElementById('date-start');
          const formEndInput = document.getElementById('date-end');
          if (formStartInput) formStartInput.value = oneMonthAgoStr;
          if (formEndInput) formEndInput.value = todayStr;

          const updateDateInputs = () => {
            // Update form inputs when summary date inputs change
            const formStartInput = document.getElementById('date-start');
            const formEndInput = document.getElementById('date-end');

            if (formStartInput && formEndInput) {
              formStartInput.value = startDateInput.value;
              formEndInput.value = endDateInput.value;

              // Trigger search parameter change event
              document.dispatchEvent(
                new CustomEvent('searchParameterChanged', {
                  detail: {
                    type: 'date',
                    dateType: 'custom',
                    dateStart: startDateInput.value,
                    dateEnd: endDateInput.value,
                  },
                })
              );
            }
          };

          // Update end date min when start date changes
          startDateInput.addEventListener('change', () => {
            endDateInput.min = startDateInput.value;
            updateDateInputs();
          });

          endDateInput.addEventListener('change', updateDateInputs);
        };

        // FORCE RESTORE mini date inputs - but preserve existing values
        const forceRestoreDateInputs = () => {
          const summaryValueDiv = document.querySelector(
            '[data-field="date"] .search-summary-value'
          );
          if (summaryValueDiv && !summaryValueDiv.querySelector('.mini-date-inputs')) {
            // Only create new inputs if they don't exist
            const today = new Date();
            const oneMonthAgo = new Date(today);
            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
            const todayStr = today.toISOString().split('T')[0];
            const oneMonthAgoStr = oneMonthAgo.toISOString().split('T')[0];

            // Check if there are existing values from form inputs
            const existingStartInput = document.getElementById('date-start');
            const existingEndInput = document.getElementById('date-end');
            const startValue = existingStartInput?.value || oneMonthAgoStr;
            const endValue = existingEndInput?.value || todayStr;

            summaryValueDiv.innerHTML = `
                        <div class="mini-date-inputs" id="mini-date-container">
                            <input type="text" id="summary-start-date" class="mini-date-input" placeholder="YYYY-MM-DD" maxlength="10" value="${startValue}">
                            <span class="date-separator">to</span>
                            <input type="text" id="summary-end-date" class="mini-date-input" placeholder="YYYY-MM-DD" maxlength="10" value="${endValue}">
                        </div>
                    `;

            // Setup simple date input listeners
            const startInput = document.getElementById('summary-start-date');
            const endInput = document.getElementById('summary-end-date');
            if (startInput && endInput && window.searchSummaryManager) {
              window.searchSummaryManager.setupSimpleDateInputListeners(startInput);
              window.searchSummaryManager.setupSimpleDateInputListeners(endInput);
            }
          } else {
          }
        };

        // Force restore immediately and repeatedly - RE-ENABLED WITH CUSTOM INPUTS
        forceRestoreDateInputs();
        setTimeout(forceRestoreDateInputs, 10);
        setTimeout(forceRestoreDateInputs, 100);
        setTimeout(forceRestoreDateInputs, 500);
        setTimeout(forceRestoreDateInputs, 1000);

        // Set up continuous monitoring every 2 seconds - RE-ENABLED WITH CUSTOM INPUTS
        setInterval(() => {
          const summaryValueDiv = document.querySelector(
            '[data-field="date"] .search-summary-value'
          );
          if (summaryValueDiv && !summaryValueDiv.querySelector('.mini-date-inputs')) {
            console.log('üîÑ forceRestoreDateInputs triggered by interval');
            forceRestoreDateInputs();
          }
        }, 2000);

        // Start initialization immediately and also run it multiple times to ensure it works - TEMPORARILY DISABLED FOR DEBUGGING
        /*
            initializeDateInputs();
            
            // Also try again after a short delay to ensure DOM is ready
            setTimeout(initializeDateInputs, 50);
            setTimeout(initializeDateInputs, 200);
            setTimeout(initializeDateInputs, 500);
            */

        // Disable click handler on TIME button to prevent old dropdown
        const timeButton = document.getElementById('summary-date');
        if (timeButton) {
          timeButton.addEventListener('click', e => {
            e.preventDefault();
            e.stopPropagation();
          });
        }

        // Initialize preset button handlers - DEPRECATED: Now handled by InlineDropdownManager
        /*
            const initializePresetButtons = () => {
                // Helper function to update both summary and form inputs
                const updateDateInputs = (startDate, endDate) => {
                    // Update summary date inputs
                    const summaryStartInput = document.getElementById('summary-start-date');
                    const summaryEndInput = document.getElementById('summary-end-date');
                    const formStartInput = document.getElementById('date-start');
                    const formEndInput = document.getElementById('date-end');
                    
                    if (summaryStartInput) summaryStartInput.value = startDate;
                    if (summaryEndInput) summaryEndInput.value = endDate;
                    if (formStartInput) formStartInput.value = startDate;
                    if (formEndInput) formEndInput.value = endDate;
                    
                    // Trigger search parameter change event
                    document.dispatchEvent(new CustomEvent('searchParameterChanged', {
                        detail: {
                            type: 'date',
                            dateType: 'custom',
                            dateStart: startDate,
                            dateEnd: endDate
                        }
                    }));
                };
                
                // 7D button
                const preset7DBtn = document.getElementById('preset-last-7-days');
                if (preset7DBtn) {
                    preset7DBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Remove active class from all preset buttons
                        document.querySelectorAll('.preset-mini-btn').forEach(btn => btn.classList.remove('active'));
                        preset7DBtn.classList.add('active');
                        
                        const today = new Date();
                        const endDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                        const startDate = new Date(endDate);
                        startDate.setDate(startDate.getDate() - 7);
                        
                        updateDateInputs(
                            startDate.toISOString().split('T')[0],
                            endDate.toISOString().split('T')[0]
                        );
                        
                    });
                }
                
                // 30D button
                const preset30DBtn = document.getElementById('preset-last-30-days');
                if (preset30DBtn) {
                    preset30DBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Remove active class from all preset buttons
                        document.querySelectorAll('.preset-mini-btn').forEach(btn => btn.classList.remove('active'));
                        preset30DBtn.classList.add('active');
                        
                        const today = new Date();
                        const endDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                        const startDate = new Date(endDate);
                        startDate.setDate(startDate.getDate() - 30);
                        
                        updateDateInputs(
                            startDate.toISOString().split('T')[0],
                            endDate.toISOString().split('T')[0]
                        );
                        
                    });
                }
                
                // 2025 button
                const preset2025Btn = document.getElementById('preset-this-year');
                if (preset2025Btn) {
                    preset2025Btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Remove active class from all preset buttons
                        document.querySelectorAll('.preset-mini-btn').forEach(btn => btn.classList.remove('active'));
                        preset2025Btn.classList.add('active');
                        
                        const today = new Date();
                        updateDateInputs(
                            `${today.getFullYear()}-01-01`,
                            today.toISOString().split('T')[0]
                        );
                        
                    });
                }
                
                // 2024 button
                const preset2024Btn = document.getElementById('preset-2024');
                if (preset2024Btn) {
                    preset2024Btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Remove active class from all preset buttons
                        document.querySelectorAll('.preset-mini-btn').forEach(btn => btn.classList.remove('active'));
                        preset2024Btn.classList.add('active');
                        
                        updateDateInputs('2024-01-01', '2024-12-31');
                        
                    });
                }
                
            }; // End of deprecated initializePresetButtons function
            */

        // Initialize preset buttons immediately and with delays
        // Preset buttons are now handled by InlineDropdownManager

        // Additional check to prevent scrolling issues
        setTimeout(() => {
          const modal = document.querySelector('.collection-details-modal-overlay');
          if (modal) {
            modal.style.display = 'none';
            modal.classList.remove('active');
          }

          // Ensure app is not scrollable
          document.documentElement.style.overflow = 'hidden';
          document.body.style.overflow = 'hidden';
          document.body.style.height = '100vh';
        }, 2000);

        // Initialize mini location input functionality
        const initializeLocationInput = () => {
          const locationInput = document.getElementById('summary-location-input');
          if (!locationInput) return;

          let searchTimeout = null;
          let currentRequest = null;

          // Function to handle location search with geocoding service
          const handleLocationSearch = async query => {
            if (!query || query.length < 2) {
              return;
            }

            try {
              // Check if geocoding service is available

              // Wait for geocoding service to be available
              if (!window.geocodingService && window.initializeGeocodingService) {
                await window.initializeGeocodingService();
              }

              const service = window.geocodingService;
              if (!service) {
                console.warn('‚ö†Ô∏è Geocoding service not available after initialization attempt');
                return;
              }

              // Use the geocoding service to search
              service.searchLocations(query, (results, error) => {
                if (error) {
                  console.error('‚ùå Location search error:', error);
                  hideLocationResults();
                  return;
                }

                if (results && results.length > 0) {
                  showLocationResults(results);
                } else {
                  hideLocationResults();
                }
              });
            } catch (error) {
              console.error('Error in location search:', error);
            }
          };

          // Function to show location results in a dropdown
          const showLocationResults = results => {
            hideLocationResults(); // Clear any existing dropdown

            const dropdown = document.createElement('div');
            dropdown.id = 'location-results-dropdown';
            dropdown.className = 'location-results-dropdown';

            // Debug styling to make it very visible
            dropdown.style.cssText = `
                        background: #2a2a2a;
                        border: 2px solid #667eea;
                        border-radius: 6px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
                        max-height: 200px;
                        overflow-y: auto;
                        display: block !important;
                    `;

            results.slice(0, 5).forEach((result, index) => {
              const item = document.createElement('div');
              item.className = 'location-result-item';
              item.style.cssText = `
                            padding: 12px;
                            cursor: pointer;
                            border-bottom: 1px solid #404040;
                            background: #2a2a2a;
                            color: white;
                        `;
              item.innerHTML = `
                            <div class="search-result-name">${result.shortName || result.name || result.display_name}</div>
                            <div class="search-result-type">${result.type || 'Location'}</div>
                        `;

              item.addEventListener('click', () => {
                selectLocationResult(result);
                hideLocationResults();
              });

              item.addEventListener('mouseenter', () => {
                item.style.background = '#333333';
                // Show location preview on map
                showLocationPreview(result);
              });

              item.addEventListener('mouseleave', () => {
                item.style.background = '#2a2a2a';
                // Clear location preview
                clearLocationPreview();
              });

              dropdown.appendChild(item);
            });

            // Position dropdown below the input - use document.body to avoid container clipping
            const rect = locationInput.getBoundingClientRect();
            dropdown.style.position = 'fixed';
            dropdown.style.top = rect.bottom + window.scrollY + 2 + 'px';
            dropdown.style.left = rect.left + 'px';
            dropdown.style.width = rect.width + 'px';
            dropdown.style.zIndex = '9999';

            document.body.appendChild(dropdown);
          };

          // Function to hide location results dropdown
          const hideLocationResults = () => {
            const existing = document.getElementById('location-results-dropdown');
            if (existing) {
              existing.remove();
            }
          };

          // Function to select a location result
          const selectLocationResult = result => {
            const displayName = result.shortName || result.name || result.display_name;

            // Update the bbox input if bbox is available
            if (result.bbox && Array.isArray(result.bbox) && result.bbox.length === 4) {
              const bboxInput = document.getElementById('bbox-input');
              if (bboxInput) {
                bboxInput.value = result.bbox.join(',');
                bboxInput.dispatchEvent(new Event('change'));
              }
            }

            // Update the location input value
            locationInput.value = displayName;

            // Trigger search parameter change event
            document.dispatchEvent(
              new CustomEvent('searchParameterChanged', {
                detail: {
                  type: 'location',
                  location: result.bbox || [result.lon, result.lat],
                  locationName: displayName,
                },
              })
            );
          };

          // Function to show location preview on map
          const showLocationPreview = result => {
            try {
              // Get the map manager from the global scope
              const mapManager = window.stacExplorer?.mapManager;
              if (!mapManager) {
                console.warn('Map manager not available for location preview');
                return;
              }

              let bbox = null;

              // Get bounding box from result
              if (result.bbox && Array.isArray(result.bbox) && result.bbox.length === 4) {
                bbox = result.bbox;
              } else if (result.lon && result.lat) {
                // Create a small bbox around the point
                const margin = 0.1; // ~11km at equator
                bbox = [
                  parseFloat(result.lon) - margin,
                  parseFloat(result.lat) - margin,
                  parseFloat(result.lon) + margin,
                  parseFloat(result.lat) + margin,
                ];
              }

              if (bbox && bbox.length === 4) {
                // Use displayBboxOnMap to show the location with zoom
                const locationName = result.display_name || result.name || 'Location Preview';
                mapManager.displayBboxOnMap(bbox, locationName);
              }
            } catch (error) {
              console.error('Error showing location preview:', error);
            }
          };

          // Function to clear location preview from map
          const clearLocationPreview = () => {
            try {
              const mapManager = window.stacExplorer?.mapManager;
              if (!mapManager) return;

              // Clear the search bbox (which is used for location display)
              if (typeof mapManager.clearSearchBbox === 'function') {
                mapManager.clearSearchBbox();
              }
            } catch (error) {
              console.error('Error clearing location preview:', error);
            }
          };

          // Add input event listener with debouncing
          locationInput.addEventListener('input', e => {
            const query = e.target.value.trim();

            // Clear previous timeout
            if (searchTimeout) {
              clearTimeout(searchTimeout);
            }

            // Set new timeout for debounced search
            searchTimeout = setTimeout(() => {
              handleLocationSearch(query);
            }, 500);
          });

          // Add enter key handler for immediate search
          locationInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
              e.preventDefault();
              const query = e.target.value.trim();
              if (query) {
                // Clear timeout and search immediately
                if (searchTimeout) {
                  clearTimeout(searchTimeout);
                }
                handleLocationSearch(query);
              }
            } else if (e.key === 'Escape') {
              hideLocationResults();
            }
          });

          // Hide dropdown when clicking outside
          document.addEventListener('click', e => {
            const dropdown = document.getElementById('location-results-dropdown');
            if (dropdown && !locationInput.contains(e.target) && !dropdown.contains(e.target)) {
              hideLocationResults();
            }
          });
        };

        // Initialize location input
        initializeLocationInput();
        setTimeout(initializeLocationInput, 100);
        setTimeout(initializeLocationInput, 500);

        // Disable click handler on LOCATION element to prevent old dropdown
        const locationElement = document.getElementById('summary-location');
        if (locationElement) {
          locationElement.addEventListener('click', e => {
            // Allow clicks to reach the input field
            if (e.target.id === 'summary-location-input') {
              return;
            }
            e.preventDefault();
            e.stopPropagation();
            // Focus the input instead
            const locationInput = document.getElementById('summary-location-input');
            if (locationInput) {
              locationInput.focus();
            }
          });
        }
      });

      // Simple date input initialization - no complex modal system needed
    </script>
    <!-- Leaflet JavaScript for mini maps -->
    <!-- Core JavaScript -->

    <!-- Initialize shared URL handling for collection details -->
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        // Handle shared URLs for collection details
        const urlParams = new URLSearchParams(window.location.search);
        const collectionId = urlParams.get('collection');
        const source = urlParams.get('source');
        const action = urlParams.get('action');

        if (collectionId && action === 'details') {
          // Wait for app to initialize, then trigger collection details
          setTimeout(() => {
            document.dispatchEvent(
              new CustomEvent('loadSharedCollection', {
                detail: {
                  collectionId: collectionId,
                  source: source,
                },
              })
            );
          }, 2000);
        }
      });
    </script>

    <!-- STAC Item Load Modal -->
    <div id="stac-load-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3><i class="material-icons">file_download</i> Load STAC Item</h3>
          <button class="modal-close" id="stac-modal-close">
            <i class="material-icons">close</i>
          </button>
        </div>
        <div class="modal-body">
          <div class="load-method-tabs">
            <button id="load-url-tab" class="tab-btn active">
              <i class="material-icons">link</i>
              From URL
            </button>
            <button id="load-json-tab" class="tab-btn">
              <i class="material-icons">code</i>
              From JSON
            </button>
          </div>

          <!-- URL Load Tab -->
          <div id="url-load-content" class="tab-content active">
            <div class="form-group">
              <label for="stac-item-url-modal">STAC Item URL</label>
              <input
                type="url"
                id="stac-item-url-modal"
                placeholder="https://example.com/path/to/item.json"
              />
              <div class="form-help">üí° Paste a direct link to a STAC item JSON file</div>
            </div>
            <div class="form-actions">
              <button id="load-url-btn-modal" class="md-btn md-btn-primary">
                <i class="material-icons">download</i>
                Load from URL
              </button>
            </div>
          </div>

          <!-- JSON Load Tab -->
          <div id="json-load-content" class="tab-content">
            <div class="form-group">
              <label for="stac-item-json-modal">STAC Item JSON</label>
              <textarea
                id="stac-item-json-modal"
                placeholder="Paste your STAC item JSON here..."
                rows="10"
              ></textarea>
              <div class="form-help">üí° Paste the complete STAC item JSON content</div>
            </div>
            <div class="form-actions">
              <button id="load-json-btn-modal" class="md-btn md-btn-primary">
                <i class="material-icons">upload</i>
                Load from JSON
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <style>
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 10000;
        display: none;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
      }

      .modal-content {
        background: var(--surface-elevated, #1e1e1e);
        border-radius: 16px;
        box-shadow: 0 16px 64px rgba(0, 0, 0, 0.5);
        border: 1px solid var(--border-primary, rgba(255, 255, 255, 0.1));
        overflow: hidden;
      }

      /* Modal Overlay */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
      }

      .modal-dialog {
        background: var(--surface-primary, #1e1e1e);
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-height: 90vh;
        overflow-y: auto;
        margin: 20px;
      }

      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        background: var(--surface-secondary, #2a2a2a);
        border-bottom: 1px solid var(--border-primary, rgba(255, 255, 255, 0.1));
      }

      .modal-header h3 {
        margin: 0;
        display: flex;
        align-items: center;
        gap: 12px;
        color: var(--text-primary, #ffffff);
        font-size: 18px;
        font-weight: 600;
      }

      .modal-close {
        background: none;
        border: none;
        color: var(--text-secondary, #888);
        cursor: pointer;
        padding: 8px;
        border-radius: 8px;
        transition: all 0.2s ease;
      }

      .modal-close:hover {
        background: var(--surface-primary, rgba(255, 255, 255, 0.1));
        color: var(--text-primary, #ffffff);
      }

      .modal-body {
        padding: 24px;
      }

      .load-method-tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 24px;
        background: var(--surface-primary, #1a1a1a);
        padding: 4px;
        border-radius: 12px;
      }

      .tab-btn {
        flex: 1;
        padding: 12px 16px;
        background: none;
        border: none;
        border-radius: 8px;
        color: var(--text-secondary, #888);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        font-weight: 500;
      }

      .tab-btn.active {
        background: var(--primary-500, #2196f3);
        color: white;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      .form-group {
        margin-bottom: 20px;
      }

      .form-group label {
        display: block;
        margin-bottom: 8px;
        color: var(--text-primary, #ffffff);
        font-weight: 500;
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 12px 16px;
        background: var(--surface-primary, #1a1a1a);
        border: 1px solid var(--border-secondary, rgba(255, 255, 255, 0.2));
        border-radius: 8px;
        color: var(--text-primary, #ffffff);
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
      }

      .form-group input:focus,
      .form-group textarea:focus {
        outline: none;
        border-color: var(--primary-500, #2196f3);
        box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
      }

      .form-help {
        margin-top: 8px;
        font-size: 12px;
        color: var(--text-secondary, #888);
      }

      .form-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      /* Header Action Button */
      .header-action-btn {
        background: none;
        border: none;
        color: var(--text-secondary, #888);
        cursor: pointer;
        padding: 8px;
        border-radius: 8px;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .header-action-btn:hover {
        background: var(--surface-primary, rgba(255, 255, 255, 0.1));
        color: var(--primary-400, #64b5f6);
        transform: translateY(-1px);
      }

      .header-action-btn .material-icons {
        font-size: 20px;
      }

      /* Update md-card-header to support flex layout */
      .md-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      /* Search History Dropdown Styles */
      .search-history-dropdown {
        position: relative;
        display: inline-block;
      }

      .history-menu {
        position: fixed !important;
        background: var(--surface-elevated, #2a2a2a) !important;
        border: 1px solid var(--border-primary, rgba(255, 255, 255, 0.1)) !important;
        border-radius: 8px !important;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
        z-index: 2147483647 !important;
        min-width: 300px !important;
        max-width: 400px !important;
        max-height: 400px !important;
        overflow-y: auto !important;
        display: none !important;
        backdrop-filter: blur(12px) !important;
        -webkit-backdrop-filter: blur(12px) !important;
      }

      .history-menu.active {
        display: block !important;
      }

      .history-header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border-primary, rgba(255, 255, 255, 0.1));
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-weight: 600;
        color: var(--text-primary, #ffffff);
        font-size: 14px;
      }

      .clear-history-btn {
        background: none;
        border: none;
        color: var(--text-secondary, #888);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.2s ease;
      }

      .clear-history-btn:hover {
        background: var(--danger-color, #ef4444);
        color: white;
      }

      .history-list {
        padding: 8px 0;
      }

      .history-item {
        padding: 10px 16px;
        cursor: pointer;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        transition: all 0.2s ease;
      }

      .history-item:hover {
        background: var(--surface-primary, rgba(255, 255, 255, 0.05));
      }

      .history-item:last-child {
        border-bottom: none;
      }

      .history-title {
        font-size: 13px;
        font-weight: 500;
        color: var(--text-primary, #ffffff);
        margin-bottom: 4px;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .history-meta {
        font-size: 11px;
        color: var(--text-secondary, #888);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .history-empty {
        padding: 20px 16px;
        text-align: center;
        color: var(--text-secondary, #888);
        font-size: 13px;
      }

      .search-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      /* Settings Modal Styles */
      .settings-section {
        margin-bottom: 24px;
      }

      .settings-section h4 {
        margin: 0 0 16px 0;
        color: var(--text-primary, #ffffff);
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .setting-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px;
        background: var(--surface-primary, #1a1a1a);
        border-radius: 8px;
        border: 1px solid var(--border-secondary, rgba(255, 255, 255, 0.1));
        margin-bottom: 12px;
      }

      .setting-content {
        flex: 1;
      }

      .setting-label {
        font-weight: 500;
        color: var(--text-primary, #ffffff);
        margin-bottom: 4px;
      }

      .setting-description {
        font-size: 13px;
        color: var(--text-secondary, #888);
        line-height: 1.4;
      }

      .setting-control {
        margin-left: 16px;
      }

      .setting-status {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        background: var(--surface-secondary, #2a2a2a);
        border-radius: 8px;
        font-size: 13px;
        color: var(--text-secondary, #888);
      }

      .setting-status.active {
        background: rgba(16, 185, 129, 0.1);
        color: #10b981;
        border: 1px solid rgba(16, 185, 129, 0.3);
      }

      .setting-status.inactive {
        background: rgba(239, 68, 68, 0.1);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      /* Toggle Switch */
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 48px;
        height: 24px;
      }

      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--surface-tertiary, #444);
        transition: 0.3s;
        border-radius: 24px;
      }

      .slider:before {
        position: absolute;
        content: '';
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: var(--primary-500, #2196f3);
      }

      input:checked + .slider:before {
        transform: translateX(24px);
      }

      /* Settings Description Section */
      .setting-description-section {
        margin-bottom: 20px;
        padding: 12px 16px;
        background: var(--surface-secondary, #252525);
        border-radius: 6px;
        border-left: 3px solid var(--accent-color, #667eea);
      }

      .setting-description-section p {
        margin: 0;
        color: var(--text-secondary, #aaaaaa);
        font-size: 14px;
        line-height: 1.4;
      }

      /* Theme Selector Styles */
      .theme-selector {
        background: var(--surface-primary, #1a1a1a);
        color: var(--text-primary, #ffffff);
        border: 1px solid var(--border-primary, rgba(255, 255, 255, 0.15));
        border-radius: var(--border-radius-sm, 6px);
        padding: 8px 12px;
        font-size: 14px;
        min-width: 120px;
        cursor: pointer;
        transition: var(--transition-fast, all 0.2s ease);
      }

      .theme-selector:hover {
        background: var(--hover-background, rgba(255, 255, 255, 0.1));
        border-color: var(--primary-400, #64b5f6);
      }

      .theme-selector:focus {
        outline: none;
        border-color: var(--primary-500, #2196f3);
        box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
      }

      .theme-selector option {
        background: var(--surface-elevated, #1a1a1a);
        color: var(--text-primary, #ffffff);
      }

      /* Mini Date Inputs Styling - Simple Text Inputs */
      .mini-date-inputs {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: nowrap;
        justify-content: flex-start;
      }

      .mini-date-input {
        /* Simple text input with YYYY-MM-DD format */
        background: #ffffff;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        color: #1f2937;
        font-size: 11px;
        padding: 2px 4px;
        width: 70px;
        min-width: 70px;
        height: 28px;
        transition: all 0.2s ease;
        font-family:
          'Segoe UI',
          system-ui,
          -apple-system,
          monospace;
        box-sizing: border-box;
        text-align: center;
        /* Always display YYYY-MM-DD format */
        direction: ltr !important;
        unicode-bidi: embed !important;
      }

      .mini-date-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        background: #f9fafb;
      }

      .mini-date-input:hover {
        border-color: #9ca3af;
        background: #f9fafb;
      }

      .mini-date-input.error {
        border-color: #dc3545;
        background-color: #ffeaea;
      }

      .date-separator {
        color: var(--text-secondary, #aaaaaa);
        font-size: 11px;
        font-weight: 500;
        padding: 0 2px;
      }

      /* Modern Date Dropdown Styling */
      .date-dropdown-modern {
        padding: 12px;
        background: var(--surface-elevated, #ffffff);
        border-radius: 12px;
        box-shadow:
          0 10px 25px -5px rgba(0, 0, 0, 0.1),
          0 10px 10px -5px rgba(0, 0, 0, 0.04);
        border: 1px solid var(--border-primary, rgba(0, 0, 0, 0.08));
      }

      .date-presets-modern {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .date-preset-btn-modern {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        border: 1px solid var(--border-secondary, rgba(0, 0, 0, 0.06));
        background: var(--surface-primary, #ffffff);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        text-align: left;
        min-height: 52px;
        position: relative;
        overflow: hidden;
      }

      .date-preset-btn-modern::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          135deg,
          rgba(102, 126, 234, 0.05) 0%,
          rgba(118, 75, 162, 0.05) 100%
        );
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .date-preset-btn-modern:hover {
        transform: translateY(-1px);
        box-shadow:
          0 8px 20px -4px rgba(0, 0, 0, 0.1),
          0 4px 8px -2px rgba(0, 0, 0, 0.04);
        border-color: var(--primary-200, rgba(102, 126, 234, 0.2));
      }

      .date-preset-btn-modern:hover::before {
        opacity: 1;
      }

      .date-preset-btn-modern:active {
        transform: translateY(0);
        box-shadow:
          0 4px 12px -2px rgba(0, 0, 0, 0.08),
          0 2px 4px -1px rgba(0, 0, 0, 0.04);
      }

      .preset-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 8px;
        color: white;
        flex-shrink: 0;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      }

      .preset-icon .material-icons {
        font-size: 18px;
      }

      .preset-content {
        display: flex;
        flex-direction: column;
        gap: 2px;
        flex: 1;
      }

      .preset-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary, #1f2937);
        line-height: 1.2;
      }

      .preset-desc {
        font-size: 12px;
        color: var(--text-secondary, #6b7280);
        line-height: 1.2;
      }


      /* Mini Location Input Styling (matching mini date inputs) */
      .mini-location-input-container {
        display: flex;
        align-items: center;
        justify-content: flex-start;
      }

      .mini-location-input {
        background: var(--surface-elevated, #2a2a2a);
        border: 1px solid var(--border-color, #404040);
        border-radius: 6px;
        color: var(--text-primary, #ffffff);
        font-size: 11px;
        padding: 2px 6px;
        width: 140px;
        min-width: 140px;
        height: 28px;
        transition: all 0.2s ease;
        font-family:
          'Segoe UI',
          system-ui,
          -apple-system,
          sans-serif;
        box-sizing: border-box;
        text-align: left;
      }

      .mini-location-input:focus {
        outline: none;
        border-color: var(--accent-color, #667eea);
        box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        background: var(--surface-elevated-hover, #333333);
      }

      .mini-location-input:hover {
        border-color: var(--border-hover, #555555);
        background: var(--surface-elevated-hover, #333333);
      }

      .mini-location-input::placeholder {
        color: var(--text-secondary, #aaaaaa);
        font-size: 11px;
      }

      /* Force draw button to match input field height */
      #draw-bbox-inline.location-action-btn {
        height: 28px !important;
        min-height: 28px !important;
        max-height: 28px !important;
        padding: 2px 6px !important;
        box-sizing: border-box !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        font-size: 9px !important;
        line-height: 1 !important;
        margin: 0 !important;
        vertical-align: top !important;
        align-self: flex-start !important;
      }

      #draw-bbox-inline.location-action-btn .material-icons {
        font-size: 12px !important;
        line-height: 1 !important;
        margin: 0 !important;
        padding: 0 !important;
      }

      /* Force location search value to be horizontal */
      .location-card-main .search-summary-value {
        display: flex !important;
        flex-direction: row !important;
        align-items: center !important;
        gap: 8px !important;
        width: 100% !important;
        white-space: normal !important;
        overflow: visible !important;
        text-overflow: clip !important;
        margin-top: 0 !important;
      }

      /* Prevent preset buttons from triggering parent clicks */
      .time-presets-mini {
        pointer-events: auto !important;
        position: relative !important;
        z-index: 10 !important;
      }

      .preset-mini-btn {
        pointer-events: auto !important;
        position: relative !important;
        z-index: 11 !important;
      }

      /* Force source card to be one line */
      .source-card-main .search-summary-content {
        display: flex !important;
        flex-direction: row !important;
        align-items: center !important;
        gap: 8px !important;
      }

      /* Remove bottom padding/margin from search rows */
      .search-summary-row {
        margin-bottom: 0px !important;
      }

      .search-summary-interface {
        padding-bottom: 0px !important;
      }
    </style>

    <script>
      // Prevent preset buttons from triggering parent dropdown
      document.addEventListener('DOMContentLoaded', function() {
        const presetContainer = document.querySelector('.time-presets-mini');
        if (presetContainer) {
          presetContainer.addEventListener('click', function(e) {
            e.stopPropagation();
          });
        }
        
        // Add event listener to prevent time card clicks on preset buttons
        const presetButtons = document.querySelectorAll('.preset-mini-btn');
        presetButtons.forEach(button => {
          button.addEventListener('click', function(e) {
            e.stopPropagation();
            // Don't prevent default - let preset functionality work
          }, true); // Use capture phase
        });
      });
    </script>

    <style>

      /* Location Results Dropdown */
      .location-results-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--surface-elevated, #2a2a2a);
        border: 1px solid var(--border-color, #404040);
        border-radius: 6px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        max-height: 200px;
        overflow-y: auto;
        margin-top: 2px;
      }

      .location-result-item {
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color, #404040);
        transition: background-color 0.2s ease;
      }

      .location-result-item:last-child {
        border-bottom: none;
      }

      .location-result-item:hover {
        background: var(--surface-elevated-hover, #333333);
      }

      .location-result-name {
        font-size: 12px;
        color: var(--text-primary, #ffffff);
        font-weight: 500;
      }

      .location-result-type {
        font-size: 10px;
        color: var(--text-secondary, #aaaaaa);
        margin-top: 2px;
      }

      /* Hide/minimize calendar icon to save space */
      .mini-date-input::-webkit-calendar-picker-indicator {
        display: none;
      }

      /* Fix date input internal layout and text */
      .mini-date-input::-webkit-datetime-edit-fields-wrapper {
        padding: 0;
        margin: 0;
      }

      .mini-date-input::-webkit-datetime-edit {
        padding: 0;
        margin: 0;
      }

      .mini-date-input::-webkit-datetime-edit-text {
        color: var(--text-secondary, #888888);
        padding: 0 1px;
      }

      .mini-date-input::-webkit-datetime-edit-month-field,
      .mini-date-input::-webkit-datetime-edit-day-field,
      .mini-date-input::-webkit-datetime-edit-year-field {
        color: var(--text-primary, #ffffff);
        padding: 0;
        margin: 0;
      }

      .mini-date-input::-webkit-datetime-edit-year-field {
        min-width: 35px;
      }

      /* Light theme adjustments */
      /* Light theme styles are now the default - no overrides needed */




      /* Dark theme adjustments - only apply when NOT in light theme */
    </style>

    <!-- Search History Dropdown Portal (outside all containers to avoid clipping) -->
    <div id="header-search-history-menu" class="history-menu">
      <div class="history-header">
        <span>Recent Searches</span>
        <button id="header-clear-history-btn" class="clear-history-btn" title="Clear History">
          <i class="material-icons">delete</i>
        </button>
      </div>
      <div id="header-search-history-list" class="history-list">
        <div class="history-empty">No search history yet</div>
      </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
      <div class="modal-dialog">
        <div class="modal-header">
          <h3><i class="material-icons">settings</i> Settings</h3>
          <button class="modal-close" id="settings-modal-close">
            <i class="material-icons">close</i>
          </button>
        </div>
        <div class="modal-body">
          <div class="settings-section">
            <h4><i class="material-icons">palette</i> Appearance</h4>
            <div class="setting-item">
              <div class="setting-content">
                <div class="setting-label">Theme</div>
                <div class="setting-description">Choose your preferred color theme</div>
              </div>
              <div class="setting-control">
                <select id="theme-selector" class="theme-selector">
                  <option value="auto">Auto (System)</option>
                  <option value="dark">Dark</option>
                  <option value="light">Light</option>
                </select>
              </div>
            </div>
          </div>

          <div class="settings-section">
            <h4><i class="material-icons">speed</i> Performance</h4>
            <div class="setting-item">
              <div class="setting-content">
                <div class="setting-label">GPU Acceleration</div>
                <div class="setting-description">
                  Use Deck.gl for hardware-accelerated rendering when possible
                </div>
              </div>
              <div class="setting-control">
                <label class="toggle-switch">
                  <input type="checkbox" id="gpu-acceleration-toggle" checked />
                  <span class="slider"></span>
                </label>
              </div>
            </div>
            <div class="setting-status" id="gpu-status-display">
              <i class="material-icons">info</i>
              <span id="gpu-status-text">Checking GPU acceleration status...</span>
            </div>
          </div>

          <div class="settings-section">
            <h4><i class="material-icons">storage</i> Data Catalogs</h4>
            <div class="setting-description-section">
              <p>
                Enable or disable data catalogs for search. Disabled catalogs won't appear in
                collection dropdowns.
              </p>
            </div>

            <!-- Collection toggles populated dynamically from collections.json -->
            <div id="catalog-toggles-modal-container"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Smart Filter System Modal -->
    <div id="smart-filters-modal" class="modal-overlay filter-modal">
      <div class="modal-dialog filter-modal-dialog">
        <div class="modal-header">
          <h3><i class="material-icons">tune</i> Data Filters</h3>
          <button class="modal-close" id="filters-modal-close">
            <i class="material-icons">close</i>
          </button>
        </div>
        <div class="modal-body" id="smart-filters-container">
          <!-- FilterManager will populate this -->
        </div>
      </div>
    </div>
  </body>
</html>
